{"version":3,"sources":["block.ts","transaction.ts","chain.ts","wallet.ts","index.tsx"],"names":["Block","index","prevHash","currHash","transactions","timestamp","Date","now","this","Transaction","amount","from","to","message","Chain","genericCryptoKey","type","extractable","algorithm","name","usages","genesisTransaction","genesisPrevHash","Array","fill","join","genesisCurrHash","randomHash","replace","length","len","bufferToHex","window","crypto","getRandomValues","Uint32Array","a","msgUint8","TextEncoder","encode","subtle","digest","hashBuffer","hashArray","Uint8Array","hashHex","map","b","toString","padStart","nonce","leadingZeros","console","log","candidateSolution","Number","MAX_SAFE_INTEGER","digestMessage","substr","split","every","bit","transaction","signature","data","stringToArrayBuffer","JSON","stringify","verify","hash","push","addBlock","numZeros","Math","round","random","targetHash","re","RegExp","zerosStr","targetStr","acceptableHashFound","mine","newHash","newBlock","lastBlock","str","buf","ArrayBuffer","bufView","Uint16Array","i","strLen","charCodeAt","instance","Wallet","publicKey","generateKey","namedCurve","keyPair","privateKey","sign","verifyTransaction","App","useState","blockChain","setBlockChain","useEffect","lior","initialize","bamba","anon","sendMoney","main","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.bf0ea262.chunk.js","sourcesContent":["import { Transaction } from \"./transaction.js\";\r\n\r\nexport class Block {\r\n  index: number;\r\n  prevHash: string;\r\n  currHash: string;\r\n  transactions: Transaction[];\r\n  timestamp = Date.now();\r\n\r\n  constructor(index: number, prevHash: string, currHash: string, transactions: Transaction[]) {\r\n    this.index = index;\r\n    this.prevHash = prevHash;\r\n    this.currHash = currHash;\r\n    this.transactions = transactions;\r\n  }\r\n}\r\n","export class Transaction {\r\n  amount: number;\r\n  from: CryptoKey;\r\n  to: CryptoKey;\r\n  message?: string;\r\n\r\n  constructor(amount: number, from: CryptoKey, to: CryptoKey, message?: string) {\r\n    this.amount = amount;\r\n    this.from = from;\r\n    this.to = to;\r\n    this.message = message;\r\n  }\r\n}\r\n","import { Block } from \"./block\";\r\nimport { Transaction } from \"./transaction\";\r\n\r\nexport class Chain {\r\n  #chain: Block[];\r\n  #verifiedTransactions: Transaction[];\r\n  #BLOCK_LIMIT = 2;\r\n\r\n  static instance = new Chain();\r\n\r\n  static stringToArrayBuffer(str: string): ArrayBuffer {\r\n    const buf = new ArrayBuffer(str.length * 2); // 2 bytes for each char\r\n    const bufView = new Uint16Array(buf);\r\n    for (let i = 0, strLen = str.length; i < strLen; i++) {\r\n      bufView[i] = str.charCodeAt(i);\r\n    }\r\n    return buf;\r\n  }\r\n\r\n  static bufferToHex(hashBuffer: ArrayBuffer): string {\r\n    const hashArray = Array.from(new Uint8Array(hashBuffer)); // convert buffer to byte array\r\n    const hashHex = hashArray.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\"); // convert bytes to hex string\r\n    return hashHex;\r\n  }\r\n\r\n  constructor() {\r\n    const genericCryptoKey = {\r\n      type: \"public\",\r\n      extractable: true,\r\n      algorithm: { name: \"ECDSA\" },\r\n      usages: [\"verify\"],\r\n    } as CryptoKey;\r\n\r\n    const genesisTransaction = [new Transaction(0, genericCryptoKey, genericCryptoKey)];\r\n    const genesisPrevHash = Array(64).fill(\"0\").join(\"\");\r\n    const genesisCurrHash = this.randomHash(32).replace(/^.{0,3}/, \"000\");\r\n    this.#chain = [new Block(0, genesisPrevHash, genesisCurrHash, genesisTransaction)];\r\n    this.#verifiedTransactions = [];\r\n  }\r\n\r\n  get blockChain(): Block[] {\r\n    return this.#chain;\r\n  }\r\n\r\n  get lastBlock(): Block {\r\n    return this.#chain[this.#chain.length - 1];\r\n  }\r\n\r\n  randomHash(len: number): string {\r\n    return Chain.bufferToHex(window.crypto.getRandomValues(new Uint32Array(len)));\r\n  }\r\n\r\n  async digestMessage(message: string): Promise<string> {\r\n    const msgUint8 = new TextEncoder().encode(message); // encode as (utf-8) Uint8Array\r\n    const hashBuffer = await window.crypto.subtle.digest(\"SHA-256\", msgUint8); // hash the message\r\n    const hashArray = Array.from(new Uint8Array(hashBuffer)); // convert buffer to byte array\r\n    const hashHex = hashArray.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\"); // convert bytes to hex string\r\n    return hashHex;\r\n  }\r\n\r\n  async mine(nonce: number, leadingZeros: number): Promise<string> {\r\n    console.log(\"⚒ mining...\");\r\n\r\n    let candidateSolution = \"\";\r\n    while (nonce <= Number.MAX_SAFE_INTEGER) {\r\n      candidateSolution = await this.digestMessage(nonce.toString());\r\n\r\n      const leadingBits = candidateSolution.substr(0, leadingZeros).split(\"\");\r\n      if (leadingBits.every((bit) => bit === \"0\")) {\r\n        console.log(`Solved: ${nonce}`);\r\n        break;\r\n      }\r\n\r\n      nonce++;\r\n    }\r\n\r\n    return candidateSolution;\r\n  }\r\n\r\n  async verifyTransaction(transaction: Transaction, signature: ArrayBuffer): Promise<void> {\r\n    const data = Chain.stringToArrayBuffer(JSON.stringify(transaction));\r\n    const isValid = await crypto.subtle.verify({ name: \"ECDSA\", hash: \"SHA-256\" }, transaction.from, signature, data);\r\n\r\n    if (isValid) {\r\n      this.#verifiedTransactions.push(transaction);\r\n      console.log(\"✅ Verified Transaction!\");\r\n      console.log(`Transaction Pool Now Has ${this.#verifiedTransactions.length} Verified Transactions`);\r\n    }\r\n\r\n    if (this.#verifiedTransactions.length === this.#BLOCK_LIMIT) {\r\n      await this.addBlock(this.#verifiedTransactions);\r\n      this.#verifiedTransactions = []; // empty the verified transaction pool\r\n    }\r\n  }\r\n\r\n  async addBlock(transactions: Transaction[]): Promise<void> {\r\n    // new hash needs between 2 and 3 leading zeros\r\n    const numZeros = Math.round(Math.random() * 2) + 2;\r\n    const targetHash = await this.digestMessage(this.randomHash(20));\r\n\r\n    // replace leading bits with zeros\r\n    const re = new RegExp(`^.{0,${numZeros}}`, \"g\");\r\n    const zerosStr = Array(numZeros).fill(\"0\").join(\"\");\r\n    const targetStr = targetHash.replace(re, zerosStr);\r\n\r\n    // only add a block of transactions to the chain if it was mined successfully and the new hash is <= target\r\n    let acceptableHashFound = false;\r\n    while (!acceptableHashFound) {\r\n      const nonce = Math.round(Math.random() * 999999999);\r\n      const newHash = await this.mine(nonce, numZeros);\r\n\r\n      if (newHash <= targetStr) {\r\n        const newBlock = new Block(this.lastBlock.index + 1, this.lastBlock.currHash, newHash, transactions);\r\n        this.#chain.push(newBlock);\r\n        console.log(\"✨ Added Block To Chain\");\r\n        acceptableHashFound = true;\r\n      } else {\r\n        console.log(\"❌ Failed Mining Below Target\");\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { Chain } from \"./chain\";\r\nimport { Transaction } from \"./transaction\";\r\n\r\nexport class Wallet {\r\n  publicKey: CryptoKey = {\r\n    type: \"public\",\r\n    extractable: true,\r\n    algorithm: { name: \"ECDSA\" },\r\n    usages: [\"verify\"],\r\n  };\r\n  #privateKey: CryptoKey = {\r\n    type: \"private\",\r\n    extractable: true,\r\n    algorithm: { name: \"ECDSA\" },\r\n    usages: [\"sign\"],\r\n  };\r\n\r\n  constructor() {\r\n    // intentionally blank\r\n  }\r\n\r\n  async initialize(): Promise<void> {\r\n    const keyPair = await window.crypto.subtle.generateKey({ name: \"ECDSA\", namedCurve: \"P-256\" }, true, [\"sign\", \"verify\"]); // prettier-ignore\r\n    this.publicKey = keyPair.publicKey;\r\n    this.#privateKey = keyPair.privateKey;\r\n  }\r\n\r\n  getMessageEncoding(message: string): Uint8Array {\r\n    return new TextEncoder().encode(message);\r\n  }\r\n\r\n  async sendMoney(amount: number, to: CryptoKey, message?: string): Promise<void> {\r\n    const transaction = new Transaction(amount, this.publicKey, to, message);\r\n    const data = Chain.stringToArrayBuffer(JSON.stringify(transaction));\r\n    const signature = await window.crypto.subtle.sign({ name: \"ECDSA\", hash: \"SHA-256\" }, this.#privateKey, data);\r\n\r\n    await Chain.instance.verifyTransaction(transaction, signature);\r\n  }\r\n}\r\n","import React, { useEffect, useState } from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\n\r\nimport { Wallet } from \"./wallet\";\r\nimport { Chain } from \"./chain\";\r\nimport { Block } from \"./block\";\r\n\r\nexport default function App(): JSX.Element {\r\n  const [blockChain, setBlockChain] = useState<Block[]>();\r\n\r\n  useEffect(() => {\r\n    async function main(): Promise<void> {\r\n      const lior = new Wallet();\r\n      await lior.initialize();\r\n\r\n      const bamba = new Wallet();\r\n      await bamba.initialize();\r\n\r\n      const anon = new Wallet();\r\n      await anon.initialize();\r\n\r\n      console.log(\"A\");\r\n\r\n      // first 2 transactions\r\n      await lior.sendMoney(1e3, bamba.publicKey, \"Good dog gets money\");\r\n      await anon.sendMoney(1e6, bamba.publicKey, \"Be rich Bamba\");\r\n\r\n      // next 2 transactions\r\n      await anon.sendMoney(10, lior.publicKey, \"You deserve this much\");\r\n      await lior.sendMoney(1, anon.publicKey, \"Thank you\");\r\n\r\n      // last transaction\r\n      await bamba.sendMoney(1, lior.publicKey, \"I am rich 😀🐶\");\r\n      await lior.sendMoney(1, bamba.publicKey);\r\n\r\n      console.log(\"HERE\");\r\n      setBlockChain(Chain.instance.blockChain);\r\n    }\r\n\r\n    main();\r\n  }, []);\r\n\r\n  return (\r\n    <div>\r\n      <pre>{JSON.stringify(blockChain, null, 2)}</pre>\r\n    </div>\r\n  );\r\n}\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById(\"root\")\r\n);\r\n"],"sourceRoot":""}